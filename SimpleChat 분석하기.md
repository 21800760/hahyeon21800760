<h1> SimpleChat 분석하기 </h1>

~~~
2개 소스의 전체적인 흐름을 이해하여 설명하는 내용
각 클래스의 핵심 포인트를 이해하고 있음을 드러내는 내용
각 클래스(4개)의 역할
각 생성자, 메소드의 역할
Reader, Writer 객체들의 역할, 동작방식
Hashmap의 용도와 사용방법
실제로 동작하는 화면과 순서에 따른 소스와의 연결점
분석과 테스트를 통해 추가되었으면 하는 기능들
~~~

## ChatServer
~~~
사용자에게 인풋을 받지 않고, 단지 실행만 시킨다.

요약
1. ServerSocket은 클라이언트 연결 요청이 있을때까지 대기
2. 클라이언트가 연결 요청이 있다면 Socket을 생성하여 연결시킴
3. 연결된 Socket으로 데이터를 스트림형태로 주고 받음

- 동작 정의
① 클라이언트 여러 개가 서버에 접속할 수 있다.
② 클라이언트가 접속할 경우, 서버는 이미 접속되어 있는 클라이언트에게 “XXX님이 접속했습니다” 라는 문자열을 전송한다.
③ 클라이언트가 문자열을 전송할 경우, 서버는 접속되어 있는 모든 클라이언트에게 전달받은 문자열을 전송한다.
④ 클라이언트가 접속을 종료할 경우, 서버는 접속되어 있는 클라이언트에게 “XXX님이 접속 종료했습니다” 라는 문자열을 전송한다.

- 서버 작동
클라이언트가 보내 문자열을 접속하 모든 클라이언트에게 전송하기 위해서 스레드간에 OutputStream을 공유하는 방법이 필요: 해시 맵 사용
~~~

~~~
채팅 서버에서는 먼저 ServerSocket을 생성해서 해당 포트로 Connection 신호가 오기를 기다린다. (.accept())
.accept() 메소드에서 반환하는 클라이언트 소켓을 통해 바로 Read, Write 하지않고 멀티 유저를 수용하기 위해 유저마다 쓰레드를 생성해준다.

출처: https://jeong-pro.tistory.com/134 [기본기를 쌓는 정아마추어 코딩블로그]
~~~

~~~
각 쓰레드에서는 쓰레드가 생성될 때 소켓 통신을 할 PrintWriter와 BufferedReader를 만들고 접속한 유저의 아이디와 출력스트림(PrintWriter)을 HashMap에 key, value로 넣는다.
그리고 run()에서 쓰레드가 실행되면서 메시지가 들어오면 다른 유저 모두에게 broadcast로 메시지를 보낸다.


출처: https://jeong-pro.tistory.com/134 [기본기를 쌓는 정아마추어 코딩블로그]
~~~



## ChatClient
~~~
요약
1. Socket을 사용하여 IP,port 주소로 연결 요청
2. 연결이 되면 스트림 형태로 데이터를 주고 받음

- 동작 정의
①     채팅 클라이언트를 실행할 때 사용자의 아이디와 접속할 서버의 IP 주소를 전달
②     다른 클라이언트가 접속하면, “XXX님이 접속했습니다”란 메시지 출력
③     다른 사람의 대화 내용이 클라이언트에서 키보드로 입력하는 중에도 전달되어 화면에 출력
④     클라이언트에서 키보드로 문장을 입력한 후 엔터 키를 입력하면, 접속된 모든 클라이언트에 입력된 문자열이 전송
⑤     클라이언트를 종료하면, “XXX님이 접속 종료했습니다.”란 메시지를 출력

-클라이언트의 작동
1. 키보드로부터 입력받는 문자열은 소켓을 통해서 구한 PrintWriter를 이용해서 출력하고 서버에 문자열이 전송된다. 이 문자열을 서버로 전달하는 것은 메인 스레드로 처리
2. 키보드로 사용한 글을 입력하고 있는 중간에도 서버에서 다른 클라이언트에서 전송하 문자열을 소켓을 통하여 전달을 받아야 하기 때문에 입력스레드를 따로 이용
~~~

~~~
채팅 클라이언트는 먼저 해당 서버에 아이디와 포트번호로 연결을 시도한다.
그 후 서버와 마찬가지로 소켓을 통해 입출력 스트림을 생성한다. (PrintWriter, BufferedReader)
하지만 클라이언트에서 하나 더 생각해야 할 것은 바로 키보드로 받는 입력이다.
만약 키보드로 입력받는 부분과 서버와 통신하는 부분을 같은 쓰레드에서 사용했으면 키보드로 입력을 하는 동안에는 서버에서 오는 메시지들을 받을 수 없게 된다.
따라서 서버에서 들어오는 메시지를 받는 부분을 쓰레드로 생성해서 오는 즉시 받는다.


출처: https://jeong-pro.tistory.com/134 [기본기를 쌓는 정아마추어 코딩블로그]
~~~


~~~
# ChatServer
[요약] 
사용자에게 인풋을 받지 않고, 단지 실행만 시킨다.
1. ServerSocket은 클라이언트 연결 요청이 있을 때까지 대기
2. 클라이언트가 연결 요청이 있다면 Socket을 생성하여 연결시킴
3. 연결된 Socket으로 데이터를 스트림 형태로 주고 받음

[public class ChatServer]
채팅 서버에서는 먼저 ServerSocket을 생성해서 해당 포트로 Connection 신호가 오기를 기다린다. (.accept()메소드 사용) .accept() 메소드에서 반환하는 클라이언트 소켓을 통해 바로 Read, Write 하지않고 멀티 유저를 수용하기 위해 유저 마다 쓰레드를 생성해준다.

해시 맵 사용 : 클라이언트가 보낸 문자열을 접속한 모든 클라이언트에게 전송하기 위해서 쓰레드간에OutputStream을 공유

[class ChatThread extends Thread]
접속을 계속 유지하면서 데이터 송수신 하기 위한 클래스이다.
각 쓰레드에서는 쓰레드가 생성될 때 소켓 통신을 할 PrintWriter와 BufferedReader를 만들고 접속한 유저의 아이디와 출력스트림(PrintWriter)을 HashMap에 key, value로 넣는다.
그리고 run()에서 쓰레드가 실행되면서 메시지가 들어오면 다른 유저 모두에게 broadcast로 메시지를 보낸다. synchronized(hm)은 여러 쓰레드가 공유하는 해시 맵을 동기화 한다.

*public void run()
:클라이언트로부터 수신 받은 데이터를 클라이언트에게 송신한다.
try{
	// 만약 “/quit”라는 메세지를 읽으면 종료한다.
	// 만약 귓속말을 위해서 특정 클라이언트에게 메세지를 보냈다면 sendmsg(line)호출
	// 그 밖에 경우, 받은 메세지를 모든 클라이언트에게 브로드 캐스팅한다.
}

finally{
	// 종료메세지가 보내진 경우 여러 쓰레드가 공유하는 해쉬 맵을 동기화 한다.
	// 종료 메시지를 보낸 클라이언트의 정보를 해쉬 맵에서 삭제한다.
}
broadcast로 나머지 클라이언트에게 접속 종료를 알린다.
나간 클라이언트 객체를 close한다.

*public void sendmsg(String msg)
귓속말을 위해서 특정 클라이언트에게 메세지를 보낼 때는 /to 아이디 대화내용 형식으로 보낸다.

//귓속말로 넘어온 메세지 중 아이디 부분에 해당되는 문자열을 찾기 위해
int start = msg.indexOf(“ “) +1;
//두번째 공백 문자 사이의 문자가 아이디
int end = msg.indexOf(“ “,start);

1. 보내진 메세지 중 아이디 부분만 얻어낸다.
2. 아이디 이후는 대화 내용이 된다.
3. 해쉬 맵에서 아이디로 출력 스트림을 얻어낸다.

*public void broadcast(String msg)
받은 메시지를 모든 클라이언트에게 브로드 캐스팅한다.
여러 쓰레드가 공유하는 해쉬 맵을 동기화하고, 출력스트림을 통해 메세지 출력한다.

# ChatClient
[요약]
1. Socket을 사용하여 IP, port 주소로 연결 요청
2. 연결이 되면 스트림 형태로 데이터를 주고 받음

[public class ChatClient]
채팅 클라이언트는 먼저 해당 서버에 아이디와 포트 번호로 연결을 시도한다. 그 후 서버와 마찬가지로 소켓을 통해 입출력 스트림을 생성한다. (PrintWriter, BufferedReader)

try{
	// 입력받은 ip로 10001번 포트에 접속한다.
	// 서버로부터 데이터를 송신하기 위한 pw
	// 서버로부터 데이터를 수신받기 위한 br
	// 키보드로부터 메시지를 읽어올 입력 스트림을 생성한다.
	  (BufferedReader는 한 줄씩 읽어낼 수 있다.)
	// 서버에게 사용자 아이디를 전송한다.
	// 서버가 보낸 데이터를 수신받기 위한 스레드 객체 it 생성

	while(키보드로부터 한 줄씩 입력){
		// 서버로 데이터 송신
		// ”/quit” 메시지를 보내면 종료
	}	
}

[class InputThread extends Thread]
서버로부터 전달 받은 문자열을 모니터에 출력하는 InputThread 객체를 생성하여 Socket, BufferedReader 객체를 인자로 전달 받는다.

*public void run()
서버로부터 문자열을 읽어 들여 모니터에 출력한다.
~~~





